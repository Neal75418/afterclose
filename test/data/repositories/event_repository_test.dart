import 'package:afterclose/data/database/app_database.dart';
import 'package:afterclose/data/repositories/event_repository.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';

class MockAppDatabase extends Mock implements AppDatabase {
  @override
  Future<T> transaction<T>(Future<T> Function() action, {bool? requireNew}) {
    return action();
  }
}

class FakeStockEventCompanion extends Fake implements StockEventCompanion {}

void main() {
  setUpAll(() {
    registerFallbackValue(FakeStockEventCompanion());
  });

  late MockAppDatabase mockDb;
  late EventRepository repository;

  setUp(() {
    mockDb = MockAppDatabase();
    repository = EventRepository(database: mockDb);
  });

  // ==========================================
  // 事件查詢
  // ==========================================
  group('getEventsInRange', () {
    test('delegates to database', () async {
      final start = DateTime(2025, 1, 1);
      final end = DateTime(2025, 1, 31);
      final events = [
        StockEventEntry(
          id: 1,
          symbol: '2330',
          eventType: 'EX_DIVIDEND',
          eventDate: DateTime(2025, 1, 15),
          title: '2330 除息',
          isAutoGenerated: true,
          createdAt: DateTime(2025, 1, 1),
        ),
      ];

      when(
        () =>
            mockDb.getEventsInRange(start, end, symbols: any(named: 'symbols')),
      ).thenAnswer((_) async => events);

      final result = await repository.getEventsInRange(start, end);

      expect(result, equals(events));
      verify(() => mockDb.getEventsInRange(start, end)).called(1);
    });
  });

  group('getEventsForSymbol', () {
    test('delegates to database', () async {
      when(() => mockDb.getEventsForSymbol('2330')).thenAnswer((_) async => []);

      final result = await repository.getEventsForSymbol('2330');

      expect(result, isEmpty);
      verify(() => mockDb.getEventsForSymbol('2330')).called(1);
    });
  });

  // ==========================================
  // 事件操作
  // ==========================================
  group('addCustomEvent', () {
    test('inserts CUSTOM event with correct fields', () async {
      when(() => mockDb.insertStockEvent(any())).thenAnswer((_) async => 42);

      final eventDate = DateTime(2025, 3, 15);
      final result = await repository.addCustomEvent(
        symbol: '2330',
        eventDate: eventDate,
        title: '法說會',
        description: '第一季法說會',
      );

      expect(result, equals(42));

      final captured =
          verify(() => mockDb.insertStockEvent(captureAny())).captured.single
              as StockEventCompanion;
      expect(captured.eventType.value, equals('CUSTOM'));
      expect(captured.eventDate.value, equals(eventDate));
      expect(captured.title.value, equals('法說會'));
      expect(captured.description.value, equals('第一季法說會'));
      expect(captured.symbol.value, equals('2330'));
    });

    test('allows null symbol for personal memo events', () async {
      when(() => mockDb.insertStockEvent(any())).thenAnswer((_) async => 43);

      await repository.addCustomEvent(
        eventDate: DateTime(2025, 3, 15),
        title: '個人備忘',
      );

      final captured =
          verify(() => mockDb.insertStockEvent(captureAny())).captured.single
              as StockEventCompanion;
      // addCustomEvent passes Value(symbol) where symbol is null
      expect(captured.symbol.value, isNull);
    });
  });

  group('deleteEvent', () {
    test('delegates to database', () async {
      when(() => mockDb.deleteStockEvent(42)).thenAnswer((_) async {});

      await repository.deleteEvent(42);

      verify(() => mockDb.deleteStockEvent(42)).called(1);
    });
  });

  // ==========================================
  // 除權息日同步
  // ==========================================
  group('syncDividendEvents', () {
    test('returns 0 when no watchlist or positions', () async {
      when(() => mockDb.getWatchlist()).thenAnswer((_) async => []);
      when(() => mockDb.getPortfolioPositions()).thenAnswer((_) async => []);

      final result = await repository.syncDividendEvents();

      expect(result, equals(0));
    });

    test(
      'creates EX_DIVIDEND and EX_RIGHTS events from dividend history',
      () async {
        when(() => mockDb.getWatchlist()).thenAnswer(
          (_) async => [
            WatchlistEntry(symbol: '2330', createdAt: DateTime(2025, 1, 1)),
          ],
        );
        when(() => mockDb.getPortfolioPositions()).thenAnswer((_) async => []);
        when(() => mockDb.getDividendHistory('2330')).thenAnswer(
          (_) async => [
            const DividendHistoryEntry(
              symbol: '2330',
              year: 2024,
              cashDividend: 3.5,
              stockDividend: 0.5,
              exDividendDate: '2024-07-15',
              exRightsDate: '2024-08-20',
            ),
          ],
        );

        when(() => mockDb.deleteAutoGeneratedEvents()).thenAnswer((_) async {});
        when(() => mockDb.insertStockEvent(any())).thenAnswer((_) async => 1);

        final result = await repository.syncDividendEvents();

        // 1 exDividendDate + 1 exRightsDate = 2 events
        expect(result, equals(2));
        verify(() => mockDb.deleteAutoGeneratedEvents()).called(1);
        verify(() => mockDb.insertStockEvent(any())).called(2);
      },
    );

    test('skips null or empty dividend dates', () async {
      when(() => mockDb.getWatchlist()).thenAnswer(
        (_) async => [
          WatchlistEntry(symbol: '2330', createdAt: DateTime(2025, 1, 1)),
        ],
      );
      when(() => mockDb.getPortfolioPositions()).thenAnswer((_) async => []);
      when(() => mockDb.getDividendHistory('2330')).thenAnswer(
        (_) async => [
          const DividendHistoryEntry(
            symbol: '2330',
            year: 2024,
            cashDividend: 3.5,
            stockDividend: 0,
            exDividendDate: null,
            exRightsDate: '',
          ),
        ],
      );

      when(() => mockDb.deleteAutoGeneratedEvents()).thenAnswer((_) async {});

      final result = await repository.syncDividendEvents();

      expect(result, equals(0));
      verifyNever(() => mockDb.insertStockEvent(any()));
    });

    test('skips invalid date strings', () async {
      when(() => mockDb.getWatchlist()).thenAnswer(
        (_) async => [
          WatchlistEntry(symbol: '2330', createdAt: DateTime(2025, 1, 1)),
        ],
      );
      when(() => mockDb.getPortfolioPositions()).thenAnswer((_) async => []);
      when(() => mockDb.getDividendHistory('2330')).thenAnswer(
        (_) async => [
          const DividendHistoryEntry(
            symbol: '2330',
            year: 2024,
            cashDividend: 3.5,
            stockDividend: 0,
            exDividendDate: 'not-a-date',
          ),
        ],
      );

      when(() => mockDb.deleteAutoGeneratedEvents()).thenAnswer((_) async {});

      final result = await repository.syncDividendEvents();

      expect(result, equals(0));
      verifyNever(() => mockDb.insertStockEvent(any()));
    });

    test('deduplicates symbols from watchlist and portfolio', () async {
      when(() => mockDb.getWatchlist()).thenAnswer(
        (_) async => [
          WatchlistEntry(symbol: '2330', createdAt: DateTime(2025, 1, 1)),
        ],
      );
      when(() => mockDb.getPortfolioPositions()).thenAnswer(
        (_) async => [
          PortfolioPositionEntry(
            id: 1,
            symbol: '2330', // same symbol in both
            quantity: 1000,
            avgCost: 500,
            realizedPnl: 0,
            totalDividendReceived: 0,
            createdAt: DateTime(2025, 1, 1),
            updatedAt: DateTime(2025, 1, 1),
          ),
        ],
      );
      when(() => mockDb.getDividendHistory('2330')).thenAnswer(
        (_) async => [
          const DividendHistoryEntry(
            symbol: '2330',
            year: 2024,
            cashDividend: 3.5,
            stockDividend: 0,
            exDividendDate: '2024-07-15',
          ),
        ],
      );

      when(() => mockDb.deleteAutoGeneratedEvents()).thenAnswer((_) async {});
      when(() => mockDb.insertStockEvent(any())).thenAnswer((_) async => 1);

      final result = await repository.syncDividendEvents();

      // Only 1 event (not duplicated for same symbol)
      expect(result, equals(1));
      // getDividendHistory called once for '2330', not twice
      verify(() => mockDb.getDividendHistory('2330')).called(1);
    });
  });
}
