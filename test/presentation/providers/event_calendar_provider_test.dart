import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mocktail/mocktail.dart';

import 'package:afterclose/core/utils/clock.dart';
import 'package:afterclose/data/database/app_database.dart';
import 'package:afterclose/data/repositories/event_repository.dart';
import 'package:afterclose/presentation/providers/providers.dart';
import 'package:afterclose/presentation/providers/event_calendar_provider.dart';

// =============================================================================
// Mocks
// =============================================================================

class MockAppDatabase extends Mock implements AppDatabase {}

class MockEventRepository extends Mock implements EventRepository {}

class FakeClock implements AppClock {
  FakeClock(this._now);
  final DateTime _now;

  @override
  DateTime now() => _now;
}

// =============================================================================
// Test Helpers
// =============================================================================

StockEventEntry createEvent({
  int id = 1,
  String? symbol,
  String eventType = 'EX_DIVIDEND',
  DateTime? eventDate,
  String title = 'Test Event',
  String? description,
  bool isAutoGenerated = false,
  DateTime? createdAt,
}) {
  return StockEventEntry(
    id: id,
    symbol: symbol,
    eventType: eventType,
    eventDate: eventDate ?? DateTime(2026, 2, 15),
    title: title,
    description: description,
    isAutoGenerated: isAutoGenerated,
    createdAt: createdAt ?? DateTime(2026, 2, 1),
  );
}

// =============================================================================
// Tests
// =============================================================================

void main() {
  late MockAppDatabase mockDb;
  late MockEventRepository mockEventRepo;
  late FakeClock fakeClock;
  late ProviderContainer container;

  setUpAll(() {
    registerFallbackValue(DateTime(2026));
  });

  setUp(() {
    mockDb = MockAppDatabase();
    mockEventRepo = MockEventRepository();
    fakeClock = FakeClock(DateTime(2026, 2, 15, 10, 30));

    container = ProviderContainer(
      overrides: [
        databaseProvider.overrideWithValue(mockDb),
        eventRepositoryProvider.overrideWithValue(mockEventRepo),
        appClockProvider.overrideWithValue(fakeClock),
      ],
    );
  });

  tearDown(() {
    container.dispose();
  });

  // ===========================================================================
  // EventType
  // ===========================================================================

  group('EventType', () {
    test('fromValue parses known types', () {
      expect(EventType.fromValue('EX_DIVIDEND'), EventType.exDividend);
      expect(EventType.fromValue('EX_RIGHTS'), EventType.exRights);
      expect(EventType.fromValue('EARNINGS'), EventType.earnings);
      expect(EventType.fromValue('CUSTOM'), EventType.custom);
    });

    test('fromValue defaults to custom for unknown', () {
      expect(EventType.fromValue('UNKNOWN'), EventType.custom);
    });

    test('i18nKey returns correct keys', () {
      expect(EventType.exDividend.i18nKey, 'calendar.typeExDividend');
      expect(EventType.exRights.i18nKey, 'calendar.typeExRights');
      expect(EventType.earnings.i18nKey, 'calendar.typeEarnings');
      expect(EventType.custom.i18nKey, 'calendar.typeCustom');
    });

    test('value property contains expected strings', () {
      expect(EventType.exDividend.value, 'EX_DIVIDEND');
      expect(EventType.exRights.value, 'EX_RIGHTS');
      expect(EventType.earnings.value, 'EARNINGS');
      expect(EventType.custom.value, 'CUSTOM');
    });
  });

  // ===========================================================================
  // EventCalendarState
  // ===========================================================================

  group('EventCalendarState', () {
    test('has correct default values', () {
      const state = EventCalendarState();

      expect(state.focusedMonth, isNull);
      expect(state.selectedDate, isNull);
      expect(state.events, isEmpty);
      expect(state.selectedDayEvents, isEmpty);
      expect(state.filter, CalendarFilter.all);
      expect(state.isLoading, isFalse);
      expect(state.error, isNull);
    });

    test('copyWith preserves unset values', () {
      final state = EventCalendarState(
        focusedMonth: DateTime(2026, 2),
        filter: CalendarFilter.watchlistOnly,
        isLoading: true,
      );

      final copied = state.copyWith();
      expect(copied.focusedMonth, DateTime(2026, 2));
      expect(copied.filter, CalendarFilter.watchlistOnly);
      expect(copied.isLoading, isTrue);
    });

    test('copyWith with sentinel handles error correctly', () {
      const state = EventCalendarState(error: 'old error');

      final preserved = state.copyWith();
      expect(preserved.error, 'old error');

      final cleared = state.copyWith(error: null);
      expect(cleared.error, isNull);

      final updated = state.copyWith(error: 'new error');
      expect(updated.error, 'new error');
    });
  });

  // ===========================================================================
  // EventCalendarNotifier
  // ===========================================================================

  group('EventCalendarNotifier', () {
    test('initial state is empty', () {
      final state = container.read(eventCalendarProvider);
      expect(state.focusedMonth, isNull);
      expect(state.isLoading, isFalse);
    });

    test('init sets focused month and selected date', () async {
      when(
        () => mockEventRepo.getEventsInRange(
          any(),
          any(),
          symbols: any(named: 'symbols'),
        ),
      ).thenAnswer((_) async => []);

      final notifier = container.read(eventCalendarProvider.notifier);
      await notifier.init();

      final state = container.read(eventCalendarProvider);
      expect(state.focusedMonth, DateTime(2026, 2));
      expect(state.selectedDate, isNotNull);
      expect(state.isLoading, isFalse);
    });

    test('loadMonthEvents loads events and groups by date', () async {
      final events = [
        createEvent(id: 1, eventDate: DateTime(2026, 2, 10), title: 'Event A'),
        createEvent(id: 2, eventDate: DateTime(2026, 2, 10), title: 'Event B'),
        createEvent(id: 3, eventDate: DateTime(2026, 2, 20), title: 'Event C'),
      ];

      when(
        () => mockEventRepo.getEventsInRange(
          any(),
          any(),
          symbols: any(named: 'symbols'),
        ),
      ).thenAnswer((_) async => events);

      final notifier = container.read(eventCalendarProvider.notifier);
      await notifier.loadMonthEvents(DateTime(2026, 2));

      final state = container.read(eventCalendarProvider);
      expect(state.isLoading, isFalse);
      expect(state.events.keys, hasLength(2)); // 2 distinct dates
      expect(state.error, isNull);
    });

    test('loadMonthEvents handles error', () async {
      when(
        () => mockEventRepo.getEventsInRange(
          any(),
          any(),
          symbols: any(named: 'symbols'),
        ),
      ).thenThrow(Exception('DB error'));

      final notifier = container.read(eventCalendarProvider.notifier);
      await notifier.loadMonthEvents(DateTime(2026, 2));

      final state = container.read(eventCalendarProvider);
      expect(state.isLoading, isFalse);
      expect(state.error, isNotNull);
    });

    test('selectDate updates selected date', () async {
      // First init to populate events
      when(
        () => mockEventRepo.getEventsInRange(
          any(),
          any(),
          symbols: any(named: 'symbols'),
        ),
      ).thenAnswer((_) async => []);

      final notifier = container.read(eventCalendarProvider.notifier);
      await notifier.init();

      notifier.selectDate(DateTime(2026, 2, 20));

      final state = container.read(eventCalendarProvider);
      expect(state.selectedDate, DateTime(2026, 2, 20));
    });

    test('setFilter changes filter and reloads', () async {
      when(
        () => mockEventRepo.getEventsInRange(
          any(),
          any(),
          symbols: any(named: 'symbols'),
        ),
      ).thenAnswer((_) async => []);

      final notifier = container.read(eventCalendarProvider.notifier);
      await notifier.init();

      when(() => mockDb.getWatchlist()).thenAnswer((_) async => []);

      await notifier.setFilter(CalendarFilter.watchlistOnly);

      final state = container.read(eventCalendarProvider);
      expect(state.filter, CalendarFilter.watchlistOnly);
      verify(() => mockDb.getWatchlist()).called(1);
    });

    test('addEvent calls repository and reloads', () async {
      when(
        () => mockEventRepo.getEventsInRange(
          any(),
          any(),
          symbols: any(named: 'symbols'),
        ),
      ).thenAnswer((_) async => []);
      when(
        () => mockEventRepo.addCustomEvent(
          symbol: any(named: 'symbol'),
          eventDate: any(named: 'eventDate'),
          title: any(named: 'title'),
          description: any(named: 'description'),
        ),
      ).thenAnswer((_) async => 1);

      final notifier = container.read(eventCalendarProvider.notifier);
      await notifier.init();

      await notifier.addEvent(
        eventDate: DateTime(2026, 3, 1),
        title: 'My Event',
      );

      verify(
        () => mockEventRepo.addCustomEvent(
          symbol: null,
          eventDate: DateTime(2026, 3, 1),
          title: 'My Event',
          description: null,
        ),
      ).called(1);
    });

    test('deleteEvent calls repository and reloads', () async {
      when(
        () => mockEventRepo.getEventsInRange(
          any(),
          any(),
          symbols: any(named: 'symbols'),
        ),
      ).thenAnswer((_) async => []);
      when(() => mockEventRepo.deleteEvent(any())).thenAnswer((_) async {});

      final notifier = container.read(eventCalendarProvider.notifier);
      await notifier.init();

      await notifier.deleteEvent(42);

      verify(() => mockEventRepo.deleteEvent(42)).called(1);
    });

    test('syncDividendEvents calls repository', () async {
      when(
        () => mockEventRepo.getEventsInRange(
          any(),
          any(),
          symbols: any(named: 'symbols'),
        ),
      ).thenAnswer((_) async => []);
      when(() => mockEventRepo.syncDividendEvents()).thenAnswer((_) async => 5);

      final notifier = container.read(eventCalendarProvider.notifier);
      await notifier.init();

      final count = await notifier.syncDividendEvents();

      expect(count, 5);
      verify(() => mockEventRepo.syncDividendEvents()).called(1);
    });
  });

  // ===========================================================================
  // Provider declaration
  // ===========================================================================

  group('eventCalendarProvider', () {
    test('provides initial state', () {
      final state = container.read(eventCalendarProvider);
      expect(state, isA<EventCalendarState>());
    });

    test('notifier is accessible', () {
      final notifier = container.read(eventCalendarProvider.notifier);
      expect(notifier, isA<EventCalendarNotifier>());
    });
  });
}
